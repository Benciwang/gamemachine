BEGIN_NS

namespace gmgl_shaders
{
	struct object
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"uniform mat4 GM_shadow_matrix;\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_model_matrix;\n"
			"uniform mat4 GM_projection_matrix;\n"
			"\n"
			"layout(location = 0) in vec4 position;\n"
			"layout(location = 1) in vec4 normal;\n"
			"layout(location = 2) in vec2 uv;\n"
			"layout(location = 3) in vec4 tangent;\n"
			"layout(location = 4) in vec4 bitangent;\n"
			"layout(location = 5) in vec2 lightmapuv;\n"
			"\n"
			"out vec4 shadowCoord;\n"
			"out vec4 _normal;\n"
			"out vec2 _uv;\n"
			"out vec4 _tangent;\n"
			"out vec4 _bitangent;\n"
			"out vec2 _lightmapuv;\n"
			"out vec4 position_world;\n"
			"\n"
			"void calcCoords()\n"
			"{\n"
			"	position_world = GM_model_matrix * position;\n"
			"	vec4 position_eye = GM_view_matrix * position_world;\n"
			"	gl_Position = GM_projection_matrix * position_eye;\n"
			"	shadowCoord = GM_shadow_matrix * position_world;\n"
			"	_normal = normal;\n"
			"	_tangent = tangent;\n"
			"	_bitangent = bitangent;\n"
			"	_uv = uv;\n"
			"	_lightmapuv = lightmapuv;\n"
			"}\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"	calcCoords();\n"
			"}\n"
			;

		const GMString frag =
			"#version 330 core\n"
			"\n"
			"in vec4 _position_world;\n"
			"in vec4 _normal;\n"
			"in vec2 _uv;\n"
			"in vec4 _tangent;\n"
			"in vec4 _bitangent;\n"
			"in vec2 _lightmapuv;\n"
			"in vec4 _shadowCoord;\n"
			"\n"
			"// 阴影纹理\n"
			"uniform sampler2DShadow GM_shadow_texture;\n"
			"uniform int GM_shadow_texture_switch = 0;\n"
			"\n"
			"#define MAX_TEXTURE_COUNT 3\n"
			"#define MAX_LIGHT_COUNT 10\n"
			"struct GM_texture_t\n"
			"{\n"
			"   sampler2D texture;\n"
			"   float scroll_s;\n"
			"   float scroll_t;\n"
			"   float scale_s;\n"
			"   float scale_t;\n"
			"   int enabled;\n"
			"};\n"
			"uniform GM_texture_t GM_ambient_textures[MAX_TEXTURE_COUNT];\n"
			"uniform GM_texture_t GM_diffuse_textures[MAX_TEXTURE_COUNT];\n"
			"uniform GM_texture_t GM_lightmap_textures[MAX_TEXTURE_COUNT];  // 用到的只有1个\n"
			"uniform GM_texture_t GM_normalmap_textures[1];\n"
			"\n"
			"struct GM_light_t\n"
			"{\n"
			"   vec3 lightColor;\n"
			"   vec3 lightPosition;\n"
			"};\n"
			"uniform GM_light_t GM_ambients[MAX_LIGHT_COUNT];\n"
			"uniform GM_light_t GM_speculars[MAX_LIGHT_COUNT];\n"
			"\n"
			"struct GM_Material_t\n"
			"{\n"
			"   vec3 ka;\n"
			"   vec3 kd;\n"
			"   vec3 ks;\n"
			"   float shininess;\n"
			"};\n"
			"uniform GM_Material_t GM_material;\n"
			"\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_model_matrix;\n"
			"\n"
			"// 调试变量\n"
			"uniform int GM_debug_draw_normal;\n"
			"\n"
			"// 相机视角法向量\n"
			"vec3 g_normal_eye;\n"
			"// ShadowMap的阴影系数，如果没有ShadowMap则为1\n"
			"float g_shadeFactor = 0;\n"
			"vec3 g_ambientLight;\n"
			"vec3 g_diffuseLight;\n"
			"vec3 g_specularLight;\n"
			"\n"
			"out vec4 frag_color;\n"
			"\n"
			"void init()\n"
			"{\n"
			"   g_ambientLight = g_diffuseLight = g_specularLight = vec3(0);\n"
			"}\n"
			"\n"
			"float calcuateShadeFactor(vec4 shadowCoord)\n"
			"{\n"
			"   if (GM_shadow_texture_switch == 0)\n"
			"       return 1;\n"
			"\n"
			"   float shadeFactor = 0.0;\n"
			"   shadeFactor += textureProjOffset(GM_shadow_texture, shadowCoord, ivec2(-1, -1));\n"
			"   shadeFactor += textureProjOffset(GM_shadow_texture, shadowCoord, ivec2(1, -1));\n"
			"   shadeFactor += textureProjOffset(GM_shadow_texture, shadowCoord, ivec2(-1, 1));\n"
			"   shadeFactor += textureProjOffset(GM_shadow_texture, shadowCoord, ivec2(1, 1));\n"
			"   shadeFactor /= 4;\n"
			"\n"
			"   return shadeFactor;\n"
			"}\n"
			"\n"
			"float shadeFactorFactor(float shadeFactor)\n"
			"{\n"
			"   return min(shadeFactor + 0.3, 1);\n"
			"}\n"
			"\n"
			"void calcDiffuseAndSpecular(GM_light_t light, vec3 lightDirection, vec3 eyeDirection, vec3 normal)\n"
			"{\n"
			"   vec3 N = normalize(normal);\n"
			"   vec3 L = normalize(lightDirection);\n"
			"\n"
			"   //diffuse:\n"
			"   {\n"
			"       float diffuseFactor = dot(L, N);\n"
			"       diffuseFactor = clamp(diffuseFactor, 0.0f, 1.0f);\n"
			"\n"
			"       g_diffuseLight += diffuseFactor * GM_material.kd * g_shadeFactor * light.lightColor;\n"
			"   }\n"
			"\n"
			"   // specular:\n"
			"   {\n"
			"       vec3 V = normalize(eyeDirection);\n"
			"       vec3 R = reflect(-L, N);\n"
			"       float theta = dot(V, R);\n"
			"       float specularFactor = pow(theta, GM_material.shininess);\n"
			"       specularFactor = clamp(specularFactor, 0.0f, 1.0f);\n"
			"\n"
			"       g_specularLight += specularFactor * GM_material.ks * g_shadeFactor * light.lightColor;\n"
			"   }\n"
			"}\n"
			"\n"
			"mat4 removeTranslation(mat4 mat)\n"
			"{\n"
			"   mat4 r = mat4(\n"
			"       vec4(mat[0].xyz, 0),\n"
			"       vec4(mat[1].xyz, 0),\n"
			"       vec4(mat[2].xyz, 0),\n"
			"       vec4(0, 0, 0, 1)\n"
			"   );\n"
			"   return r;\n"
			"}\n"
			"\n"
			"void calcLights()\n"
			"{\n"
			"   g_shadeFactor = shadeFactorFactor(calcuateShadeFactor(_shadowCoord));\n"
			"\n"
			"   // 由顶点变换矩阵计算法向量变换矩阵\n"
			"   mat4 noTranslationMat = removeTranslation(GM_model_matrix);\n"
			"   mat4 normalModelTransform = transpose(inverse(noTranslationMat));\n"
			"   mat4 normalEyeTransform = GM_view_matrix * normalModelTransform;\n"
			"\n"
			"   vec4 vertex_eye = GM_view_matrix * _position_world;\n"
			"   vec3 eyeDirection_eye = vec3(0,0,0) - vertex_eye.xyz;\n"
			"   // normal的齐次向量最后一位必须位0，因为法线变换不考虑平移\n"
			"   g_normal_eye = normalize( (normalEyeTransform * vec4(_normal.xyz, 0)).xyz );\n"
			"\n"
			"   // 计算漫反射和高光部分\n"
			"   if (GM_normalmap_textures[0].enabled == 0)\n"
			"   {\n"
			"       for (int i = 0; i < MAX_LIGHT_COUNT; i++)\n"
			"       {\n"
			"           vec3 lightPosition_eye = (GM_view_matrix * vec4(GM_speculars[i].lightPosition, 1)).xyz;\n"
			"           vec3 lightDirection_eye = lightPosition_eye + eyeDirection_eye;\n"
			"           calcDiffuseAndSpecular(GM_speculars[i], lightDirection_eye, eyeDirection_eye, g_normal_eye);\n"
			"       }\n"
			"   }\n"
			"   else\n"
			"   {\n"
			"       vec3 normal_tangent = texture(GM_normalmap_textures[0].texture, _uv).rgb * 2.0 - 1.0;\n"
			"       vec3 tangent_eye = normalize((normalEyeTransform * vec4(_tangent.xyz, 0)).xyz);\n"
			"       vec3 bitangent_eye = normalize((normalEyeTransform * vec4(_bitangent.xyz, 0)).xyz);\n"
			"       for (int i = 0; i < MAX_LIGHT_COUNT; i++)\n"
			"       {\n"
			"           vec3 lightPosition_eye = (GM_view_matrix * vec4(GM_speculars[i].lightPosition, 1)).xyz;\n"
			"           vec3 lightDirection_eye = lightPosition_eye + eyeDirection_eye;\n"
			"           mat3 TBN = transpose(mat3(\n"
			"               tangent_eye,\n"
			"               bitangent_eye,\n"
			"               g_normal_eye.xyz\n"
			"           ));\n"
			"           vec3 lightDirection_tangent = TBN * lightDirection_eye;\n"
			"           vec3 eyeDirection_tangent = TBN * eyeDirection_eye;\n"
			"\n"
			"           calcDiffuseAndSpecular(GM_speculars[i], lightDirection_tangent, eyeDirection_tangent, normal_tangent);\n"
			"       }\n"
			"   }\n"
			"\n"
			"   // 计算环境光\n"
			"   for (int i = 0; i < MAX_LIGHT_COUNT; i++)\n"
			"   {\n"
			"       g_ambientLight += GM_material.ka * GM_ambients[i].lightColor * g_shadeFactor;\n"
			"   }\n"
			"}\n"
			"\n"
			"vec3 calcTexture(GM_texture_t textures[MAX_TEXTURE_COUNT], vec2 uv, int size)\n"
			"{\n"
			"   bool hasTexture = false;\n"
			"   vec3 result = vec3(0);\n"
			"   for (int i = 0; i < size; i++)\n"
			"   {\n"
			"       result += textures[i].enabled == 1\n"
			"           ? vec3(texture(textures[i].texture, uv * vec2(textures[i].scale_s, textures[i].scale_t) + vec2(textures[i].scroll_s, textures[i].\n""scroll_t)))\n"
			"           : vec3(0);\n"
			"       if (textures[i].enabled == 1)\n"
			"           hasTexture = true;\n"
			"   }\n"
			"\n"
			"   if (!hasTexture)\n"
			"       return vec3(1);\n"
			"\n"
			"   return result;\n"
			"}\n"
			"\n"
			"void calcColor()\n"
			"{\n"
			"   calcLights();\n"
			"\n"
			"   if (GM_debug_draw_normal == 1)\n"
			"   {\n"
			"       // 画眼睛视角的法向量\n"
			"       frag_color = vec4((g_normal_eye.xyz + 1.f) / 2.f, 1.f);\n"
			"       return;\n"
			"   }\n"
			"   else if (GM_debug_draw_normal == 2)\n"
			"   {\n"
			"       // 画世界视角的法向量\n"
			"       frag_color = vec4((_normal.xyz + 1.f) / 2.f, 1.f);\n"
			"       return;\n"
			"   }\n"
			"   vec3 diffuseTextureColor = calcTexture(GM_diffuse_textures, _uv, MAX_TEXTURE_COUNT);\n"
			"   vec3 ambientTextureColor = calcTexture(GM_ambient_textures, _uv, MAX_TEXTURE_COUNT) *\n"
			"       calcTexture(GM_lightmap_textures, _lightmapuv, 1);\n"
			"\n"
			"   // 最终结果\n"
			"   vec3 color = g_ambientLight * ambientTextureColor + g_diffuseLight * diffuseTextureColor + g_specularLight;\n"
			"   frag_color = vec4(color, 1.0f);\n"
			"}\n"
			"\n"
			"void main()\n"
			"{\n"
			"   init();\n"
			"   calcColor();\n"
			"}\n"
			;
	} object;

	struct object_pass
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"uniform mat4 GM_shadow_matrix;\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_model_matrix;\n"
			"uniform mat4 GM_projection_matrix;\n"
			"\n"
			"layout (location = 0) in vec4 position;\n"
			"layout (location = 1) in vec4 normal;\n"
			"layout (location = 2) in vec2 uv;\n"
			"layout (location = 3) in vec4 tangent;\n"
			"layout (location = 4) in vec4 bitangent;\n"
			"layout (location = 5) in vec2 lightmapuv;\n"
			"\n"
			"out vec4 _shadowCoord;\n"
			"out vec4 _normal;\n"
			"out vec2 _uv;\n"
			"out vec4 _tangent;\n"
			"out vec4 _bitangent;\n"
			"out vec2 _lightmapuv;\n"
			"out vec4 _position_world;\n"
			"\n"
			"void calcCoords()\n"
			"{\n"
			"    gl_Position = GM_projection_matrix * GM_view_matrix * GM_model_matrix * position;\n"
			"    _shadowCoord = GM_shadow_matrix * GM_model_matrix * _position_world;\n"
			"    \n"
			"    _position_world = position;\n"
			"    _normal = normal;\n"
			"    _tangent = tangent;\n"
			"    _bitangent = bitangent;\n"
			"    _uv = uv;\n"
			"    _lightmapuv = lightmapuv;\n"
			"}\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    calcCoords();\n"
			"}\n"
			;

		const GMString frag =
			"#version 330 core\n"
			"\n"
			"in vec4 _position_world;\n"
			"in vec4 _normal;\n"
			"in vec2 _uv;\n"
			"in vec4 _tangent;\n"
			"in vec4 _bitangent;\n"
			"in vec2 _lightmapuv;\n"
			"in vec4 _shadowCoord;\n"
			"\n"
			"#define MAX_TEXTURE_COUNT 3\n"
			"\n"
			"struct GM_texture_t\n"
			"{\n"
			"	sampler2D texture;\n"
			"	float scroll_s;\n"
			"	float scroll_t;\n"
			"	float scale_s;\n"
			"	float scale_t;\n"
			"	int enabled;\n"
			"};\n"
			"uniform GM_texture_t GM_ambient_textures[MAX_TEXTURE_COUNT];\n"
			"uniform GM_texture_t GM_diffuse_textures[MAX_TEXTURE_COUNT];\n"
			"uniform GM_texture_t GM_lightmap_textures[MAX_TEXTURE_COUNT];  // 用到的只有1个\n"
			"uniform GM_texture_t GM_normalmap_textures[1];\n"
			"\n"
			"out vec4 frag_color;\n"
			"\n"
			"layout (location = 0) out vec3 gWorld;\n"
			"layout (location = 1) out vec3 gNormal;\n"
			"layout (location = 2) out vec3 gTexAmbient;\n"
			"layout (location = 3) out vec3 gTexDiffuse;\n"
			"layout (location = 4) out vec3 gTangent;\n"
			"layout (location = 5) out vec3 gBitangent;\n"
			"layout (location = 6) out vec3 gNormalMap;\n"
			"\n"
			"vec3 calcTexture(GM_texture_t textures[MAX_TEXTURE_COUNT], vec2 uv, int size)\n"
			"{\n"
			"	bool hasTexture = false;\n"
			"	vec3 result = vec3(0);\n"
			"	for (int i = 0; i < size; i++)\n"
			"	{\n"
			"		result += textures[i].enabled == 1\n"
			"			? vec3(texture(textures[i].texture, uv * vec2(textures[i].scale_s, textures[i].scale_t) + vec2(textures[i].scroll_s, textures[i].scroll_t)))\n"
			"			: vec3(0);\n"
			"		if (textures[i].enabled == 1)\n"
			"			hasTexture = true;\n"
			"	}\n"
			"\n"
			"	if (!hasTexture)\n"
			"		return vec3(1);\n"
			"\n"
			"	return result;\n"
			"}\n"
			"\n"
			"void main()\n"
			"{\n"
			"	gWorld = _position_world.xyz;\n"
			"	gNormal = _normal.xyz;\n"
			"	gTexAmbient = calcTexture(GM_ambient_textures, _uv, MAX_TEXTURE_COUNT) * calcTexture(GM_lightmap_textures, _lightmapuv, 1);\n"
			"	gTexDiffuse = calcTexture(GM_diffuse_textures, _uv, MAX_TEXTURE_COUNT);\n"
			"	gTangent = _tangent.xyz;\n"
			"	gBitangent = _bitangent.xyz;\n"
			"	gNormalMap = texture(GM_normalmap_textures[0].texture, _uv).rgb;\n"
			"}\n"
			;
	} object_pass;

	struct glyph
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"layout (location = 0) in vec4 position;\n"
			"layout (location = 2) in vec2 uv;\n"
			"out vec2 _uv;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"	gl_Position = position;\n"
			"	_uv = uv;\n"
			"}\n"
			;
			
		const GMString frag =
			"#version 330 core\n"
			"struct GM_texture_t\n"
			"{\n"
			"	sampler2D texture;\n"
			"	float scroll_s;\n"
			"	float scroll_t;\n"
			"	float scale_s;\n"
			"	float scale_t;\n"
			"	int enabled;\n"
			"};\n"
			"uniform GM_texture_t GM_ambient_textures[1];\n"
			"\n"
			"in vec2 _uv;\n"
			"out vec4 frag_color;\n"
			"\n"
			"void main()\n"
			"{\n"
			"	frag_color = texture(GM_ambient_textures[0].texture, \n"
			"		_uv * vec2(GM_ambient_textures[0].scale_s, GM_ambient_textures[0].scale_t) + vec2(GM_ambient_textures[0].scroll_s, GM_ambient_textures[0].scroll_t)\n"
			"	);\n"
			"}\n"
			;
	} glyph;

	struct particles
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_projection_matrix;\n"
			"\n"
			"layout (location = 0) in vec4 position;\n"
			"layout (location = 2) in vec2 uv;\n"
			"layout (location = 6) in vec4 color;\n"
			"\n"
			"out vec2 _uv;\n"
			"out vec4 _color;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    _uv = uv;\n"
			"    _color = color;\n"
			"    gl_Position = GM_projection_matrix * GM_view_matrix * position;\n"
			"}\n"
			;

		const GMString frag =
			"#version 330 core\n"
			"\n"
			"in vec2 _uv;\n"
			"in vec4 _color;\n"
			"\n"
			"struct GM_texture_t\n"
			"{\n"
			"	sampler2D texture;\n"
			"	float scroll_s;\n"
			"	float scroll_t;\n"
			"	float scale_s;\n"
			"	float scale_t;\n"
			"	int enabled;\n"
			"};\n"
			"uniform GM_texture_t GM_ambient_texture;\n"
			"\n"
			"out vec4 frag_color;\n"
			"\n"
			"vec4 calcTexture(GM_texture_t tex, vec2 uv)\n"
			"{\n"
			"	bool hasTexture = false;\n"
			"	vec4 result = vec4(0);\n"
			"	result += tex.enabled == 1\n"
			"		? texture(tex.texture, uv * vec2(tex.scale_s, tex.scale_t) + vec2(tex.scroll_s, tex.scroll_t))\n"
			"		: vec4(0);\n"
			"	if (tex.enabled == 1)\n"
			"		hasTexture = true;\n"
			"\n"
			"	if (!hasTexture)\n"
			"		return vec4(1);\n"
			"\n"
			"	return result;\n"
			"}\n"
			"\n"
			"void main()\n"
			"{\n"
			"	frag_color = calcTexture(GM_ambient_texture, _uv) * _color;\n"
			"}\n"
			;
	} particles;

	struct deferred_light_pass
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"layout (location = 0) in vec3 position;\n"
			"layout (location = 1) in vec2 texCoords;\n"
			"\n"
			"out vec4 _position_world;\n"
			"out vec2 _texCoords;\n"
			"\n"
			"void main()\n"
			"{\n"
			"    _position_world = vec4(position, 1.0f);\n"
			"    gl_Position = _position_world;\n"
			"    _texCoords = texCoords;\n"
			"}\n"
			;

		const GMString frag = 
			"#version 330 core\n"
			"\n"
			"#define MAX_LIGHT_COUNT 10\n"
			"\n"
			"in vec2 _texCoords;\n"
			"\n"
			"uniform sampler2D gPosition;\n"
			"uniform sampler2D gNormal_eye;\n"
			"uniform sampler2D gTexAmbient;\n"
			"uniform sampler2D gTexDiffuse;\n"
			"uniform sampler2D gTangent_eye;\n"
			"uniform sampler2D gBitangent_eye;\n"
			"uniform sampler2D gNormalMap;\n"
			"uniform sampler2D gKa;\n"
			"uniform sampler2D gKd;\n"
			"uniform sampler2D gKs;\n"
			"uniform sampler2D gShininess;\n"
			"uniform sampler2D gHasNormalMap;\n"
			"\n"
			"// geometries\n"
			"vec3 tPosition;\n"
			"vec3 tNormal_eye;\n"
			"vec3 tTexAmbient;\n"
			"vec3 tTexDiffuse;\n"
			"vec3 tTangent_eye;\n"
			"vec3 tBitangent_eye;\n"
			"vec3 tNormalMap;\n"
			"\n"
			"// materials\n"
			"vec3 tKa;\n"
			"vec3 tKd;\n"
			"vec3 tKs;\n"
			"float tShininess;\n"
			"\n"
			"// flags, -1 or 1\n"
			"float tHasNormalMap;\n"
			"\n"
			"struct GM_light_t\n"
			"{\n"
			"	vec3 lightColor;\n"
			"	vec3 lightPosition;\n"
			"};\n"
			"uniform GM_light_t GM_ambients[MAX_LIGHT_COUNT];\n"
			"uniform GM_light_t GM_speculars[MAX_LIGHT_COUNT];\n"
			"\n"
			"uniform mat4 GM_view_matrix;\n"
			"\n"
			"// 调试变量\n"
			"uniform int GM_debug_draw_normal;\n"
			"\n"
			"// 相机视角法向量\n"
			"vec3 g_normal_eye;\n"
			"// ShadowMap的阴影系数，如果没有ShadowMap则为1\n"
			"vec3 g_ambientLight;\n"
			"vec3 g_diffuseLight;\n"
			"vec3 g_specularLight;\n"
			"\n"
			"out vec4 frag_color;\n"
			"\n"
			"bool hasFlag(float flag)\n"
			"{\n"
			"	return flag > 0;\n"
			"}\n"
			"\n"
			"void init()\n"
			"{\n"
			"	g_ambientLight = g_diffuseLight = g_specularLight = vec3(0);\n"
			"	tPosition = texture(gPosition, _texCoords).rgb;\n"
			"	tNormal_eye = texture(gNormal_eye, _texCoords).rgb;\n"
			"	tTexAmbient = texture(gTexAmbient, _texCoords).rgb;\n"
			"	tTexDiffuse = texture(gTexDiffuse, _texCoords).rgb;\n"
			"	tTangent_eye = texture(gTangent_eye, _texCoords).rgb;\n"
			"	tBitangent_eye = texture(gBitangent_eye, _texCoords).rgb;\n"
			"	tNormalMap = texture(gNormalMap, _texCoords).rgb;\n"
			"	tKa = texture(gKa, _texCoords).rgb;\n"
			"	tKd = texture(gKd, _texCoords).rgb;\n"
			"	tKs = texture(gKs, _texCoords).rgb;\n"
			"	tShininess = texture(gShininess, _texCoords).r;\n"
			"	tHasNormalMap = texture(gHasNormalMap, _texCoords).r;\n"
			"}\n"
			"\n"
			"void calcDiffuseAndSpecular(GM_light_t light, vec3 lightDirection, vec3 eyeDirection, vec3 normal)\n"
			"{\n"
			"	vec3 N = normalize(normal);\n"
			"	vec3 L = normalize(lightDirection);\n"
			"\n"
			"	//diffuse:\n"
			"	{\n"
			"		float diffuseFactor = dot(L, N);\n"
			"		diffuseFactor = clamp(diffuseFactor, 0.0f, 1.0f);\n"
			"\n"
			"		g_diffuseLight += diffuseFactor * tKd * light.lightColor;\n"
			"	}\n"
			"\n"
			"	// specular:\n"
			"	{\n"
			"		vec3 V = normalize(eyeDirection);\n"
			"		vec3 R = reflect(-L, N);\n"
			"		float theta = dot(V, R);\n"
			"		float specularFactor = pow(theta, tShininess);\n"
			"		specularFactor = clamp(specularFactor, 0.0f, 1.0f);\n"
			"\n"
			"		g_specularLight += specularFactor * tKs * light.lightColor;\n"
			"	}\n"
			"}\n"
			"\n"
			"void calcLights()\n"
			"{\n"
			"	// 由顶点变换矩阵计算法向量变换矩阵\n"
			"	vec4 vertex_eye = GM_view_matrix * vec4(tPosition, 1);\n"
			"	vec3 eyeDirection_eye = vec3(0,0,0) - vertex_eye.xyz;\n"
			"\n"
			"	// 计算漫反射和高光部分\n"
			"	if (!hasFlag(tHasNormalMap))\n"
			"	{\n"
			"		for (int i = 0; i < MAX_LIGHT_COUNT; i++)\n"
			"		{\n"
			"			vec3 lightPosition_eye = (GM_view_matrix * vec4(GM_speculars[i].lightPosition, 1)).xyz;\n"
			"			vec3 lightDirection_eye = lightPosition_eye + eyeDirection_eye;\n"
			"			calcDiffuseAndSpecular(GM_speculars[i], lightDirection_eye, eyeDirection_eye, tNormal_eye);\n"
			"		}\n"
			"	}\n"
			"	else\n"
			"	{\n"
			"		vec3 normal_tangent = tNormalMap.rgb * 2.0 - 1.0;\n"
			"		for (int i = 0; i < MAX_LIGHT_COUNT; i++)\n"
			"		{\n"
			"			vec3 lightPosition_eye = (GM_view_matrix * vec4(GM_speculars[i].lightPosition, 1)).xyz;\n"
			"			vec3 lightDirection_eye = lightPosition_eye + eyeDirection_eye;\n"
			"			mat3 TBN = transpose(mat3(\n"
			"				tTangent_eye,\n"
			"				tBitangent_eye,\n"
			"				tNormal_eye\n"
			"			));\n"
			"			vec3 lightDirection_tangent = TBN * lightDirection_eye;\n"
			"			vec3 eyeDirection_tangent = TBN * eyeDirection_eye;\n"
			"\n"
			"			calcDiffuseAndSpecular(GM_speculars[i], lightDirection_tangent, eyeDirection_tangent, normal_tangent);\n"
			"		}\n"
			"	}\n"
			"\n"
			"	// 计算环境光\n"
			"	for (int i = 0; i < MAX_LIGHT_COUNT; i++)\n"
			"	{\n"
			"		g_ambientLight += tKa * GM_ambients[i].lightColor;\n"
			"	}\n"
			"}\n"
			"\n"
			"void calcColor()\n"
			"{\n"
			"	calcLights();\n"
			"\n"
			"	// 最终结果\n"
			"	vec3 color = g_ambientLight * tTexAmbient + g_diffuseLight * tTexDiffuse + g_specularLight;\n"
			"	frag_color = vec4(color, 1.0f);\n"
			"}\n"
			"\n"
			"void main()\n"
			"{\n"
			"	init();\n"
			"	calcColor();\n"
			"}\n"
			;
	} deferred_light_pass;

	struct deferred_geometry_pass
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"uniform mat4 GM_shadow_matrix;\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_model_matrix;\n"
			"uniform mat4 GM_projection_matrix;\n"
			"\n"
			"layout (location = 0) in vec4 position;\n"
			"layout (location = 1) in vec4 normal;\n"
			"layout (location = 2) in vec2 uv;\n"
			"layout (location = 3) in vec4 tangent;\n"
			"layout (location = 4) in vec4 bitangent;\n"
			"layout (location = 5) in vec2 lightmapuv;\n"
			"\n"
			"out vec4 _shadowCoord;\n"
			"out vec4 _normal;\n"
			"out vec2 _uv;\n"
			"out vec4 _tangent;\n"
			"out vec4 _bitangent;\n"
			"out vec2 _lightmapuv;\n"
			"out vec4 _position_world;\n"
			"\n"
			"void calcCoords()\n"
			"{\n"
			"    gl_Position = GM_projection_matrix * GM_view_matrix * GM_model_matrix * position;\n"
			"    _shadowCoord = GM_shadow_matrix * GM_model_matrix * _position_world;\n"
			"    \n"
			"    _position_world = position;\n"
			"    _normal = normal;\n"
			"    _tangent = tangent;\n"
			"    _bitangent = bitangent;\n"
			"    _uv = uv;\n"
			"    _lightmapuv = lightmapuv;\n"
			"}\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    calcCoords();\n"
			"}\n"
			;

		const GMString frag =
			"#version 330 core\n"
			"\n"
			"in vec4 _position_world;\n"
			"in vec4 _normal;\n"
			"in vec2 _uv;\n"
			"in vec4 _tangent;\n"
			"in vec4 _bitangent;\n"
			"in vec2 _lightmapuv;\n"
			"in vec4 _shadowCoord;\n"
			"\n"
			"#define MAX_TEXTURE_COUNT 3\n"
			"\n"
			"struct GM_texture_t\n"
			"{\n"
			"	sampler2D texture;\n"
			"	float scroll_s;\n"
			"	float scroll_t;\n"
			"	float scale_s;\n"
			"	float scale_t;\n"
			"	int enabled;\n"
			"};\n"
			"uniform GM_texture_t GM_ambient_textures[MAX_TEXTURE_COUNT];\n"
			"uniform GM_texture_t GM_diffuse_textures[MAX_TEXTURE_COUNT];\n"
			"uniform GM_texture_t GM_lightmap_textures[MAX_TEXTURE_COUNT];  // 用到的只有1个\n"
			"uniform GM_texture_t GM_normalmap_textures[1];\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_model_matrix;\n"
			"\n"
			"layout (location = 0) out vec3 gPosition;\n"
			"layout (location = 1) out vec3 gNormal_eye;\n"
			"layout (location = 2) out vec3 gTexAmbient;\n"
			"layout (location = 3) out vec3 gTexDiffuse;\n"
			"layout (location = 4) out vec3 gTangent_eye;\n"
			"layout (location = 5) out vec3 gBitangent_eye;\n"
			"layout (location = 6) out vec3 gNormalMap;\n"
			"\n"
			"vec3 calcTexture(GM_texture_t textures[MAX_TEXTURE_COUNT], vec2 uv, int size)\n"
			"{\n"
			"	bool hasTexture = false;\n"
			"	vec3 result = vec3(0);\n"
			"	for (int i = 0; i < size; i++)\n"
			"	{\n"
			"		result += textures[i].enabled == 1\n"
			"			? vec3(texture(textures[i].texture, uv * vec2(textures[i].scale_s, textures[i].scale_t) + vec2(textures[i].scroll_s, textures[i].scroll_t)))\n"
			"			: vec3(0);\n"
			"		if (textures[i].enabled == 1)\n"
			"			hasTexture = true;\n"
			"	}\n"
			"\n"
			"	if (!hasTexture)\n"
			"		return vec3(1);\n"
			"\n"
			"	return result;\n"
			"}\n"
			"\n"
			"mat4 removeTranslation(mat4 mat)\n"
			"{\n"
			"	mat4 r = mat4(\n"
			"		vec4(mat[0].xyz, 0),\n"
			"		vec4(mat[1].xyz, 0),\n"
			"		vec4(mat[2].xyz, 0),\n"
			"		vec4(0, 0, 0, 1)\n"
			"	);\n"
			"	return r;\n"
			"}\n"
			"\n"
			"void calcEyeSpace()\n"
			"{\n"
			"	// 由顶点变换矩阵计算法向量变换矩阵\n"
			"	mat4 noTranslationMat = removeTranslation(GM_model_matrix);\n"
			"	mat4 normalModelTransform = transpose(inverse(noTranslationMat));\n"
			"	mat4 normalEyeTransform = GM_view_matrix * normalModelTransform;\n"
			"	vec4 vertex_eye = GM_view_matrix * _position_world;\n"
			"	// normal的齐次向量最后一位必须位0，因为法线变换不考虑平移\n"
			"	gNormal_eye = normalize( (normalEyeTransform * vec4(_normal.xyz, 0)).xyz );\n"
			"\n"
			"	if (GM_normalmap_textures[0].enabled == 1)\n"
			"	{\n"
			"		gTangent_eye = normalize((normalEyeTransform * vec4(_tangent.xyz, 0)).xyz);\n"
			"		gBitangent_eye = normalize((normalEyeTransform * vec4(_bitangent.xyz, 0)).xyz);\n"
			"	}\n"
			"	else\n"
			"	{\n"
			"		gTangent_eye = vec3(0,0,0);\n"
			"		gBitangent_eye = vec3(0,0,0);\n"
			"	}\n"
			"}\n"
			"\n"
			"void main()\n"
			"{\n"
			"	gPosition = _position_world.xyz;\n"
			"	gTexAmbient = calcTexture(GM_ambient_textures, _uv, MAX_TEXTURE_COUNT) * calcTexture(GM_lightmap_textures, _lightmapuv, 1);\n"
			"	gTexDiffuse = calcTexture(GM_diffuse_textures, _uv, MAX_TEXTURE_COUNT);\n"
			"	gNormalMap = texture(GM_normalmap_textures[0].texture, _uv).rgb;\n"
			"	calcEyeSpace();\n"
			"}\n"
			;
	} deferred_geometry_pass;

	struct deferred_material_pass
	{
		const GMString vert =
			"#version 330\n"
			"\n"
			"uniform mat4 GM_view_matrix;\n"
			"uniform mat4 GM_model_matrix;\n"
			"uniform mat4 GM_projection_matrix;\n"
			"\n"
			"layout (location = 0) in vec4 position;\n"
			"\n"
			"void main(void)\n"
			"{\n"
			"    gl_Position = GM_projection_matrix * GM_view_matrix * GM_model_matrix * position;\n"
			"}\n"
			;

		const GMString frag =
			"#version 330 core\n"
			"\n"
			"struct GM_Material_t\n"
			"{\n"
			"	vec3 ka;\n"
			"	vec3 kd;\n"
			"	vec3 ks;\n"
			"	float shininess;\n"
			"};\n"
			"uniform GM_Material_t GM_material;\n"
			"\n"
			"struct GM_texture_t\n"
			"{\n"
			"	sampler2D texture;\n"
			"	float scroll_s;\n"
			"	float scroll_t;\n"
			"	float scale_s;\n"
			"	float scale_t;\n"
			"	int enabled;\n"
			"};\n"
			"uniform GM_texture_t GM_normalmap_textures[1];\n"
			"\n"
			"layout (location = 0) out vec3 gKa;\n"
			"layout (location = 1) out vec3 gKd;\n"
			"layout (location = 2) out vec3 gKs;\n"
			"layout (location = 3) out vec3 gShininess;\n"
			"layout (location = 4) out vec3 gHasNormalMap;\n"
			"\n"
			"void main()\n"
			"{\n"
			"	gKa = GM_material.ka;\n"
			"	gKd = GM_material.kd;\n"
			"	gKs = GM_material.ks;\n"
			"	gShininess = vec3(GM_material.shininess, 0, 0);\n"
			"	gHasNormalMap = GM_normalmap_textures[0].enabled == 0 ? vec3(-1, 0, 0) : vec3(1, 0, 0);\n"
			"}\n"
			;
	} deferred_material_pass;
}
END_NS
